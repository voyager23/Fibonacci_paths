void construct_fibvect(Fibvect &fv);
void construct_fibvect(Fibvect &fv) {
	fv.clear();
	fv.push_back( {0,0,0 } ); // F(0)
	fv.push_back( {1,0,0 } ); // F(1)
	
	int current_fibonacci = 0;
	do {
		current_fibonacci = (*(fv.end()-1))[0] + (*(fv.end()-2))[0];
		if(current_fibonacci < 5) {
			fv.push_back({current_fibonacci,0,0});
		} else { // pythag
			

void construct_rect_step(std::vector<Coord> &rs, Fibvect &fv);
void construct_rect_step(std::vector<Coord> &rs, Fibvect &fv) {
	// First value will be F(2) = 1
	rs.clear();
	for(auto it_fv = fv.begin()+2; it_fv != fv.end(); ++it_fv) 
		rs.push_back({(*it_fv)[0],0});	
}

void construct_pyth_step(std::vector<Coord> &ps, Fibvect &fv);
void construct_pyth_step(std::vector<Coord> &ps, Fibvect &fv) {
	// First value will be F(5) = 5,3,4
	ps.clear();
	for(auto it_fv = fv.begin()+5; it_fv < fv.end(); it_fv += 2)
		ps.push_back( {(*it_fv)[1], (*it_fv)[2]} );	
}
			
			
			
	} while (current_fibonacci < MinFibonacci);
	
	// starting at F(5) value 5, insert the pythag triples
	int idx = 5;
	fv.at(idx) = {5,3,4};
	idx +=2;
	do {
		fv.at(idx)[1] = fv.at(idx-1)[0] - fv.at(idx-2)[1];
		fv.at(idx)[2] = fv.at(idx-2)[0] + fv.at(idx-2)[1] + fv.at(idx-2)[2];	
		idx += 2;
	} while(idx < fv.size());
}
		// ----------pythagoras triple steps----------
			int wnode = w;	int hnode = h;
			int wx = 0;	int hx = 0; int temp = 0;
			for(auto it_py = pyth_step.begin(); it_py != pyth_step.end(); ++it_py) {
				bool path_found = false;

				wx = wnode - (*it_py)[0];
				hx = hnode - (*it_py)[1];	// path 1
				if((wx>=0)and(hx>=0)) {
					lattice[wnode][hnode] += lattice[wx][hx];
					lattice[wnode][hnode] %= modulus;
					path_found = true;
				}
				// switch values of wx and hx
				temp = wx;	wx = hx;  hx = temp;
				if((wx>=0)and(hx>=0)) {
					lattice[wnode][hnode] += lattice[wx][hx];
					lattice[wnode][hnode] %= modulus;
					path_found = true;
				}
							
				wx = wnode - (*it_py)[1];
				hx = hnode - (*it_py)[0];	// path 2
				if((wx>=0)and(hx>=0)) {
					lattice[wnode][hnode] += lattice[wx][hx];
					lattice[wnode][hnode] %= modulus;
					path_found = true;
				}
				
				// switch values of wx and hx
				temp = wx;	wx = hx;  hx = temp;
				if((wx>=0)and(hx>=0)) {
					lattice[wnode][hnode] += lattice[wx][hx];
					lattice[wnode][hnode] %= modulus;
					path_found = true;
				}			
				if(!path_found) break;
			} // end pythagoras			
			
			
			
									
			// ----------pythagoras triple steps----------
			int wnode = w;	int hnode = h;
			for(auto it_py = pyth_step.begin(); it_py != pyth_step.end(); ++it_py) {
				bool path_found = false;
				// ---code_block---
				int wx = wnode - (*it_py)[1];
				int hx = hnode - (*it_py)[0];	// primary node path 1
				if((wx>=0)and(hx>=0)) {
					lattice[wnode][hnode] += lattice[wx][hx];
					lattice[wnode][hnode] %= modulus;
					lattice[wnode][hnode] += lattice[hx][wx];
					lattice[wnode][hnode] %= modulus;
					path_found = true;
				}
				wx = wnode - (*it_py)[0];
				hx = hnode - (*it_py)[1];		// primary node path 2
				if((wx>=0)and(hx>=0)) {
					lattice[wnode][hnode] += lattice[wx][hx];
					lattice[wnode][hnode] %= modulus;
					lattice[wnode][hnode] += lattice[hx][wx];
					lattice[wnode][hnode] %= modulus;
					path_found = true;
				}
				// ---end_block---
				
				lattice[hnode][wnode] = lattice[wnode][hnode];
#if(0)
				// complementary node exchange values of wnode and hnode
				wnode = wnode xor hnode;
				hnode = hnode xor wnode;
				wnode = wnode xor hnode;
				// ---code_block---
				wx = wnode - (*it_py)[1];
				hx = hnode - (*it_py)[0];	// comp. node path 1
				if((wx>=0)and(hx>=0)) {
					lattice[wnode][hnode] += lattice[wx][hx];
					lattice[wnode][hnode] %= modulus;
					lattice[wnode][hnode] += lattice[hx][wx];
					lattice[wnode][hnode] %= modulus;
					path_found = true;
				}
				wx = wnode - (*it_py)[0];
				hx = hnode - (*it_py)[1];		// comp. node path 2
				if((wx>=0)and(hx>=0)) {
					lattice[wnode][hnode] += lattice[wx][hx];
					lattice[wnode][hnode] %= modulus;
					lattice[wnode][hnode] += lattice[hx][wx];
					lattice[wnode][hnode] %= modulus;
					path_found = true;
				}
				// ---end_block---
#endif
				if(!path_found) break;

			} // end pythagoras						Here are some other results:

Limit      Result      Time
-----------------------------
 1000    790802713    0.3 sec
 5000    126968109    8.8 sec
10000    860873428   42.3 sec
20000    893422979  205.8 sec
30000    451632021  509.2 sec
40000    264938001  910.5 sec
50000    395017546 1477.0 sec
60000    156903036 2164.8 sec
63000    543864149 2440.1 sec

Execution time is just under 43 seconds.

			for(auto it_py = pyth_step.begin(); it_py != pyth_step.end(); ++it_py) {
				int w_step = w - (*it_py)[0];
				int h_step = h - (*it_py)[1];
				if((w_step >= 0)and(h_step >= 0)) {
					lattice[w][h].count += lattice[w_step][h_step].count;
					lattice[w][h].count %= modulus;
					// swap coords
					w_step = w - (*it_py)[1];
					h_step = h - (*it_py)[0];					
					if((w_step >= 0)and(h_step >=0)) {
						lattice[w][h].count += lattice[w_step][h_step].count;
						lattice[w][h].count %= modulus;
					}

				} else {
					// swap coords
					w_step = w - (*it_py)[1];
					h_step = h - (*it_py)[0];				
					if((w_step >= 0)and(h_step >=0)) {
						lattice[w][h].count += lattice[w_step][h_step].count;
						lattice[w][h].count %= modulus;
					} else {
						lattice[w][h].count %= modulus;
						lattice[h][w].count = lattice[w][h].count;
						break;
					}
				}
			} // pythag steps

			// ----------pythagoras triple steps----------
			for(auto it_py = pyth_step.begin(); it_py != pyth_step.end(); ++it_py) {
				int wx = w - (*it_py)[1];
				int hx = h - (*it_py)[0];	// above diagonal
				int wy = hx;
				int hy = wx;			// below diagonal;
				bool x_fail = false;
				bool y_fail = false;
				if((wx >= 0)and(hx >= 0)) {
					lattice[w][h].count = (lattice[w][h].count + lattice[wx][hx].count) % modulus;
				} else { 
					x_fail = true;
				}
				if((wy >= 0)and(hy >= 0)) {
					lattice[w][h].count = (lattice[w][h].count + lattice[wy][hy].count) % modulus;
				} else {
					y_fail = true;
				}
				if(x_fail and y_fail) break;
				lattice[h][w].count = lattice[w][h].count;
				
			} // -------------------------------------------			
